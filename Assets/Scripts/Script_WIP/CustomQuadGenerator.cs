using System.Collections;
using System.Collections.Generic;
using UnityEngine;

/*

Explanation:

The `CustomQuadGenerator` script is attached to a game object in the Unity scene. It has three public variables: 
`widthSubdivisions`, `depthSubdivisions`, and `voronoiSubdivisions`. These variables control the number of subdivisions 
for the quad mesh and the Voronoi diagram texture.

In the `Start()` method, the script gets a reference to the mesh filter and renderer components, creates a new mesh, 
and assigns it to the mesh filter. It then calls `GenerateQuad()` to generate the quad mesh, `GenerateVoronoiTexture()` 
to generate the Voronoi diagram texture, and `ApplyTexture()` to apply the texture to the quad mesh.

In `GenerateQuad()`, the script first calculates the number of vertices and UV coordinates based on the number of 
subdivisions. It then generates a series of vertices and UV coordinates for the quad mesh. Next, it calculates the 
number of triangles and generates a series of triangles that connect the vertices together. Finally, it assigns the 
vertices, triangles, and UV coordinates to the mesh, and recalculates the normals for the mesh.

In `GenerateVoronoiTexture()`, the script creates a new 2D texture and loops through each pixel in the texture. For each 
pixel, it generates a series of random points within the bounds of the Voronoi diagram and calculates the distance between 
each point and the pixel. It then selects the point with the smallest distance and sets the color of the pixel to the 
coordinates of the selected point. This generates a Voronoi diagram texture where each pixel represents the closest point 
in the Voronoi diagram.

In `ApplyTexture()`, the script sets the main texture of the mesh renderer to the Voronoi diagram texture generated by 
`GenerateVoronoiTexture()`.

Note that this script does not include error handling or input validation. You may want to add these features to improve 
the script's robustness.
*/
public class CustomQuadGenerator : MonoBehaviour {

    public int widthSubdivisions = 1;
    public int depthSubdivisions = 1;
    public int voronoiSubdivisions = 10;

    private MeshFilter meshFilter;
    private MeshRenderer meshRenderer;
    private Mesh mesh;

    private Vector3[] vertices;
    private int[] triangles;
    private Vector2[] uv;

    private Texture2D voronoiTexture;

    private void Start() {
        meshFilter = GetComponent<MeshFilter>();
        meshRenderer = GetComponent<MeshRenderer>();
        mesh = new Mesh();
        meshFilter.mesh = mesh;

        GenerateQuad();
        GenerateVoronoiTexture();
        ApplyTexture();
    }

    private void GenerateQuad() {
        int numVertices = (widthSubdivisions + 1) * (depthSubdivisions + 1);
        vertices = new Vector3[numVertices];
        uv = new Vector2[numVertices];

        int i = 0;
        for (int z = 0; z <= depthSubdivisions; z++) {
            for (int x = 0; x <= widthSubdivisions; x++) {
                vertices[i] = new Vector3(x, 0, z);
                uv[i] = new Vector2((float)x / widthSubdivisions, (float)z / depthSubdivisions);
                i++;
            }
        }

        int numTriangles = widthSubdivisions * depthSubdivisions * 6;
        triangles = new int[numTriangles];

        int vert = 0;
        int tris = 0;
        for (int z = 0; z < depthSubdivisions; z++) {
            for (int x = 0; x < widthSubdivisions; x++) {
                triangles[tris + 0] = vert + 0;
                triangles[tris + 1] = vert + widthSubdivisions + 1;
                triangles[tris + 2] = vert + 1;
                triangles[tris + 3] = vert + 1;
                triangles[tris + 4] = vert + widthSubdivisions + 1;
                triangles[tris + 5] = vert + widthSubdivisions + 2;

                vert++;
                tris += 6;
            }
            vert++;
        }

        mesh.vertices = vertices;
        mesh.triangles = triangles;
        mesh.uv = uv;
        mesh.RecalculateNormals();
    }

    private void GenerateVoronoiTexture() {
        voronoiTexture = new Texture2D(widthSubdivisions, depthSubdivisions);
        for (int z = 0; z < depthSubdivisions; z++) {
            for (int x = 0; x < widthSubdivisions; x++) {
                float distance = float.MaxValue;
                for (int i = 0; i < voronoiSubdivisions; i++) {
                    Vector2 point = new Vector2(Random.Range(0f, 1f), Random.Range(0f, 1f));
                    float d = Vector2.Distance(point, new Vector2((float)x / widthSubdivisions, (float)z / depthSubdivisions));
                    if (d < distance) {
                        distance = d;
                        voronoiTexture.SetPixel(x, z, new Color(point.x, point.y, 0));
                        voronoiTexture.filterMode = FilterMode.Point;
                        }
                }
            }
        }
        voronoiTexture.Apply();
    }

    private void ApplyTexture() {
        meshRenderer.material.mainTexture = voronoiTexture;
        }
    }

                   
